---
title: Git hooks
description: Como configurar la firma de los commits
---

import { Steps } from '@astrojs/starlight/components';
import { LinkCard, CardGrid } from '@astrojs/starlight/components';


## ¿Qué es un Git Hook?

Un **Git hook** es un script que Git ejecuta automáticamente antes o después de eventos específicos, como hacer un commit, un push o recibir cambios en un repositorio. Los hooks permiten automatizar tareas en el flujo de trabajo de Git, como verificar la calidad del código, realizar pruebas, actualizar dependencias, o, como en nuestro caso, modificar los mensajes de commit para cumplir con una convención establecida.

### Tipos de Git Hooks:

Los hooks se dividen en dos categorías principales:

1. **Hooks del lado del cliente:**
   - *pre-commit*: Se ejecuta antes de que un commit se realice. Útil para verificar el estado del código.
   - *prepare-commit-msg*: Se ejecuta antes de que se muestre el mensaje del commit. Puede modificar el mensaje antes de que el usuario lo edite.
   - *commit-msg*: Se ejecuta después de que el usuario haya escrito el mensaje del commit. Permite modificar el mensaje final del commit.
   - *post-commit*: Se ejecuta después de que se ha realizado un commit. Útil para notificaciones o acciones de seguimiento.

2. **Hooks del lado del servidor:**
   - *pre-receive*: Se ejecuta cuando el servidor recibe un push. Puede utilizarse para validar los commits antes de aceptarlos.
   - *update*: Similar a pre-receive, pero se ejecuta una vez por cada rama que se envía.
   - *post-receive*: Se ejecuta después de que los cambios se han aceptado. Puede utilizarse para implementar servicios de integración continua o notificaciones.

## Paso a Paso para Configurar un Hook de Git

### Paso 1: Crear y actualizar el script de PowerShell

1. **Navega al directorio de hooks de Git:**

   Abre una terminal o consola de comandos y navega al directorio de hooks de tu repositorio local de Git. Este directorio se encuentra en `.git/hooks`.

   ```bash
   cd path/to/your/repo/.git/hooks
   ```

2. **Crear el archivo de script de PowerShell (`commit-msg.ps1`):**

   Abre tu editor de texto favorito y crea un nuevo archivo llamado `commit-msg.ps1` en el directorio de hooks.

3. **Copia el siguiente script de PowerShell en el archivo `commit-msg.ps1`:**

   ```powershell
   # Obtener el archivo del mensaje de commit
   param([string]$commitMsgFile)

   # Leer el mensaje de commit
   $commitMsg = Get-Content $commitMsgFile -Raw

   # Obtener el nombre de la rama actual
   $branchName = git symbolic-ref --short HEAD

   # Verificar si el nombre de la rama contiene una '/'
   if ($branchName -match '/') {
       # Extraer la parte después del último '/'
       $ticketNumber = ($branchName -split '/')[-1]
       # Preceder el número de ticket al mensaje de commit
       $newCommitMsg = "[$ticketNumber] $commitMsg"
       # Escribir el nuevo mensaje de commit al archivo
       Set-Content $commitMsgFile $newCommitMsg
   }
   ```

   Guarda los cambios en el archivo.

### Paso 2: Crear el archivo de script por lotes

1. **Crear el archivo por lotes (`commit-msg`):**

   Crea un nuevo archivo llamado `commit-msg` (sin extensión) en el mismo directorio `.git/hooks`.

2. **Copia el siguiente script por lotes en el archivo `commit-msg`:**

   ```batch
   @echo off
   powershell.exe -NoProfile -ExecutionPolicy Bypass -File "%~dp0commit-msg.ps1" %*
   ```

   Guarda los cambios en el archivo.

### Paso 3: Configurar la política de ejecución de PowerShell

1. **Permitir la ejecución de scripts locales:**

   Abre una ventana de PowerShell con permisos de administrador y ejecuta el siguiente comando:

   ```powershell
   Set-ExecutionPolicy -Scope CurrentUser RemoteSigned
   ```

   Esto permite que los scripts locales de PowerShell se ejecuten en tu sistema.

### Paso 4: Probar el Hook

1. **Ejemplos de uso:**

   - **Ejemplo 1:** Si estás en una rama llamada `feature/JIRA-0000` y haces un commit con el mensaje `Add extraParams mapper`, el mensaje final será:

     ```csharp
     [JIRA-0000] Add extraParams mapper
     ```

   - **Ejemplo 2:** Si estás en una rama llamada `hotfix/BUG-1234` y haces un commit con el mensaje `Fix null pointer exception`, el mensaje final será:

     ```csharp
     [BUG-1234] Fix null pointer exception
     ```

   - **Ejemplo 3:** Si estás en una rama llamada `release/2021.10`, el mensaje de commit será:

     ```csharp
     [2021.10] Your commit message
     ```

### Notas adicionales

- **Compatibilidad con ramas sin `/`:** Si el nombre de la rama no contiene una `/`, el script no modificará el mensaje de commit.

- **Múltiples `/` en el nombre de la rama:** El script siempre toma la parte después del último `/`. Por ejemplo, para `feature/subfeature/ABC-123`, el ticket extraído será `ABC-123`.

- **Personalización adicional:**

  - **Después del primer `/`:**

    ```powershell
    $ticketNumber = ($branchName -split '/')[1]
    ```

  - **Combinar todas las partes después del primer `/`:**

    ```powershell
    $ticketNumber = ($branchName -split '/')[1..($branchName.Length)] -join '/'
    ```

### Resumen de archivos en `.git/hooks`

- **commit-msg:** Archivo por lotes que invoca el script de PowerShell.
- **commit-msg.ps1:** Script de PowerShell que modifica el mensaje de commit.

### Conclusión

Con estos pasos, el hook de Git ahora funciona con cualquier rama que contenga una `/`, extrayendo la parte posterior para agregarla al mensaje de commit. Esto te permitirá mantener un historial de commits consistente y facilitar el seguimiento de cambios relacionados con tickets o tareas específicas, sin importar la convención de nombres de ramas que utilices.
